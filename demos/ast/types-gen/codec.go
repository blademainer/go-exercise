package main

import (
	"bytes"
	"flag"
	"fmt"
	"github.com/blademainer/go-exercise/demos/ast/types-gen/astutil"
	"go/ast"
	"go/format"
	"go/token"
	"go/types"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"strings"

	"golang.org/x/tools/go/packages"
)

const (
	DefaultParentTypeName = "Coder"  // 继承的类型，例如 `type jsonCodec Coder`，其中Coder就是typeName
	DefaultReceiverName   = "Coders" // 需要注册的对象，会将所有实现了 `Codec` 的对象注册到该实例内
	DefaultInterfaceName  = "Codec"  // 实现的接口
)

var (
	typeNames     = flag.String("type", DefaultParentTypeName, "comma-separated list of type names; must be set")
	output        = flag.String("output", "", "output file name; default srcdir/<type>_string.go")
	trimprefix    = flag.String("trimprefix", "", "trim the `prefix` from the generated constant names")
	linecomment   = flag.Bool("linecomment", false, "use line comment text as printed text when present")
	buildTags     = flag.String("tags", "", "comma-separated list of build tags to apply")
	receiver      = flag.String("receiver", DefaultReceiverName, "comma-separated list of build tags to apply")
	interfaceType = flag.String("t", DefaultInterfaceName, "interface type")
)

// Usage is a replacement usage function for the flags package.
func Usage() {
	fmt.Fprintf(os.Stderr, "Usage of types-gen:\n")
	fmt.Fprintf(os.Stderr, "\ttypes-gen [flags] -type T [directory]\n")
	fmt.Fprintf(os.Stderr, "\ttypes-gen [flags] -type T files... # Must be a single package\n")
	fmt.Fprintf(os.Stderr, "For more information, see:\n")
	fmt.Fprintf(os.Stderr, "\thttp://godoc.org/golang.org/x/tools/cmd/types-gen\n")
	fmt.Fprintf(os.Stderr, "Flags:\n")
	flag.PrintDefaults()
}

func main() {
	log.SetFlags(0)
	log.SetPrefix("types-gen: ")
	flag.Usage = Usage
	flag.Parse()
	if len(*typeNames) == 0 {
		*typeNames = DefaultParentTypeName
		//flag.Usage()
		//os.Exit(2)
	}
	if len(*receiver) == 0 {
		*receiver = DefaultReceiverName
	}
	if len(*interfaceType) == 0 {
		*interfaceType = DefaultInterfaceName
	}

	types := strings.Split(*typeNames, ",")
	var tags []string
	if len(*buildTags) > 0 {
		tags = strings.Split(*buildTags, ",")
	}

	// We accept either one directory or a list of files. Which do we have?
	args := flag.Args()
	if len(args) == 0 {
		// Default: process whole package in current directory.
		args = []string{"./demos/ast/types-gen/demo"}
	}

	// Parse the package once.
	var dir string
	g := Generator{
		trimPrefix:  *trimprefix,
		lineComment: *linecomment,
	}
	// TODO(suzmue): accept other patterns for packages (directories, list of files, import paths, etc).
	if len(args) == 1 && isDirectory(args[0]) {
		dir = args[0]
	} else {
		if len(tags) != 0 {
			log.Fatal("-tags option applies only to directories, not when files are specified")
		}
		dir = filepath.Dir(args[0])
	}

	g.parsePackage(args, tags)

	// Print the header and package clause.
	g.Printf("// Code generated by \"types-gen %s\"; DO NOT EDIT.\n", strings.Join(os.Args[1:], " "))
	g.Printf("\n")
	g.Printf("package %s", g.pkg.name)
	g.Printf("\n")

	// Run generate for each type.
	for _, typeName := range types {
		g.generate(typeName, *receiver, *interfaceType)
	}

	// Format the output.
	src := g.format()

	// Write to file.
	outputName := *output
	if outputName == "" {
		baseName := fmt.Sprintf("%s_provider.go", types[0])
		outputName = filepath.Join(dir, strings.ToLower(baseName))
	}
	err := ioutil.WriteFile(outputName, src, 0644)
	if err != nil {
		log.Fatalf("writing output: %s", err)
	}
}

// isDirectory reports whether the named file is a directory.
func isDirectory(name string) bool {
	info, err := os.Stat(name)
	if err != nil {
		log.Fatal(err)
	}
	return info.IsDir()
}

// Generator holds the state of the analysis. Primarily used to buffer
// the output for format.Source.
type Generator struct {
	pkgs *packages.Package
	buf  bytes.Buffer // Accumulated output.
	pkg  *Package     // Package we are scanning.

	typeName      string // Name of the constant type.
	interfaceType string
	owner         string
	trimPrefix    string
	lineComment   bool
	parser        *astutil.Parser
}

func (g *Generator) Printf(format string, args ...interface{}) {
	fmt.Fprintf(&g.buf, format, args...)
}

// File holds a single parsed file and associated data.
type File struct {
	pkg  *Package  // Package to which this file belongs.
	file *ast.File // Parsed AST.
	// These fields are reset for each type being generated.
	values []Value // Accumulator for constant values of that type.

	trimPrefix  string
	lineComment bool
}

type Package struct {
	name  string
	defs  map[*ast.Ident]types.Object
	files []*File
}

// parsePackage analyzes the single package constructed from the patterns and tags.
// parsePackage exits if there is an error.
func (g *Generator) parsePackage(patterns []string, tags []string) {
	cfg := &packages.Config{
		Mode: packages.LoadSyntax,
		// TODO: Need to think about constants in test files. Maybe write type_string_test.go
		// in a separate pass? For later.
		Tests:      false,
		BuildFlags: []string{fmt.Sprintf("-tags=%s", strings.Join(tags, " "))},
	}
	pkgs, err := packages.Load(cfg, patterns...)
	if err != nil {
		log.Fatal(err)
	}
	if len(pkgs) != 1 {
		log.Fatalf("error: %d packages found", len(pkgs))
	} else if len(pkgs[0].Errors) > 0 {
		log.Fatal(pkgs[0].Errors)
	}
	g.addPackage(pkgs[0])
}

// addPackage adds a type checked Package and its syntax files to the generator.
func (g *Generator) addPackage(pkg *packages.Package) {
	g.pkgs = pkg
	g.pkg = &Package{
		name:  pkg.Name,
		defs:  pkg.TypesInfo.Defs,
		files: make([]*File, len(pkg.Syntax)),
	}

	for i, file := range pkg.Syntax {
		g.pkg.files[i] = &File{
			file:        file,
			pkg:         g.pkg,
			trimPrefix:  g.trimPrefix,
			lineComment: g.lineComment,
		}
	}
}

// generate produces the String method for the named type.
func (g *Generator) generate(typeName string, owner string, interfaceType string) {
	values := make([]Value, 0, 100)
	g.typeName = typeName
	g.interfaceType = interfaceType
	g.owner = owner
	parser := astutil.NewParser(g.pkgs)
	g.parser = parser

	for _, file := range g.pkg.files {
		// Set the state for this run of the walker.
		file.values = nil
		if file.file != nil {
			ast.Inspect(file.file, g.genDeclFunc(file))
			values = append(values, file.values...)
		}
		if len(file.values) == 0 {
			continue
		}
		g.generateFunc(file)
	}

	if len(values) == 0 {
		log.Fatalf("no values defined for type %s", typeName)
	}

}

// format returns the gofmt-ed contents of the Generator's buffer.
func (g *Generator) format() []byte {
	src, err := format.Source(g.buf.Bytes())
	if err != nil {
		// Should never happen, but can arise when developing this code.
		// The user can compile the output to see the error.
		log.Printf("warning: internal error: invalid Go generated: %s", err)
		log.Printf("warning: compile the package to analyze the error")
		return g.buf.Bytes()
	}
	return src
}

// Value represents a declared constant.
type Value struct {
	originalName string // The name of the constant.
	name         string // The name with trimmed prefix.
	comment      string // The comment of the func
	ip           *astutil.InterfaceParser
}

func (v *Value) String() string {
	return v.originalName
}

func (g *Generator) genDeclFunc(f *File) func(node ast.Node) bool {
	return func(node ast.Node) bool {
		decl, ok := node.(*ast.GenDecl)
		if !ok || decl.Tok != token.TYPE {
			// We only care about const declarations.
			return true
		}
		// The name of the type of the constants we are declaring.
		// Can change if this is a multi-element declaration.
		//typ := ""
		// Loop over the elements of the declaration. Each element is a ValueSpec:
		// a list of names possibly followed by a type, possibly followed by values.
		// If the type and value are both missing, we carry down the type (and value,
		// but the "go/types" package takes care of that).
		for _, spec := range decl.Specs {
			tspec := spec.(*ast.TypeSpec) // Guaranteed to succeed as this is Type.
			fmt.Printf("type: %v\n", tspec.Name)
			fmt.Printf("type: %v\n", tspec.Type)
			id, ok := tspec.Type.(*ast.Ident) // 必须继承 typeName。例如 `type jsonCodec Coder`，其中Coder就是typeName
			if !ok {
				continue
			}

			//obj := id.Obj.Name
			fmt.Printf("id: %#v\n", id)
			fmt.Printf("id name: %v\n", id.Name)
			fmt.Printf("obj obj: %#v\n", id.Obj)
			if id.Obj == nil {
				continue
			}
			fmt.Printf("obj type: %v\n", id.Obj.Type)
			fmt.Printf("obj kind: %v\n", id.Obj.Kind)
			typeSpec := id.Obj.Decl.(*ast.TypeSpec)
			//typeId := typeSpec.Type.(*ast.Ident)
			obj, ok := f.pkg.defs[typeSpec.Name]
			if !ok {
				fmt.Printf("not found ident: %v\n", id.Name)
				continue
			}

			//obj, ok := f.pkg.defs[name]
			//
			fmt.Printf("obj: %#v\n", obj)
			if obj.Name() != g.typeName {
				continue
			}
			delimiter := ""
			builder := strings.Builder{}
			for _, comment := range tspec.Comment.List {
				builder.WriteString(delimiter)
				builder.WriteString(comment.Text)
				delimiter = "\n"
			}

			ip, err := g.parser.ParseTypeAndInterface(tspec.Name.Name, g.interfaceType)
			if err != nil {
				log.Fatalf("failed to parse type: %v, error: %v\n", tspec.Name.Name, err.Error())
			}
			ok, err = ip.IsTypeImplementsInterface()
			if err != nil || !ok {
				log.Fatalf("type: %v not implements type: %v, error: %v, ok: %v\n", tspec.Name.Name, g.interfaceType, err, ok)
			}

			v := Value{
				originalName: tspec.Name.Name,
				comment:      builder.String(),
				ip:           ip,
			}
			f.values = append(f.values, v)
		}
		return false
	}
}

func (g *Generator) generateFunc(f *File) {
	g.Printf("// Coders\n")
	g.Printf("var (\n")
	for _, value := range f.values {
		g.Printf(fmt.Sprintf(instanceTemplate, value.originalName, g.typeName))
	}
	g.Printf(")\n")

	g.Printf("// An \"Type does not implement 'Codec' as some methods are missing\" compiler error signifies that the constant values have changed.\n")
	g.Printf("\t// Re-run the types-gen command to generate them again.\n")
	g.Printf("\tfunc _() {\n")
	for _, value := range f.values {
		instanceName := g.instanceName(f, &value)
		g.Printf(validateVarTemplate, g.interfaceType, instanceName)
	}
	g.Printf("\t}\n")

	for _, value := range f.values {
		funcPrefix := fmt.Sprintf("%s%s", strings.ToUpper(value.originalName[:1]), value.originalName[1:])
		for _, code := range value.ip.FuncCodes {
			inArgs := strings.Join(code.InArgAndTypes, ",")
			outArgs := strings.Join(code.OutTypes, ",")
			inArgNames := strings.Join(code.InArgNames, ",")
			g.Printf(funcTemplate, value.originalName, g.typeName, code.FuncName, g.owner, inArgs, outArgs, inArgNames, value.comment, funcPrefix)
		}
	}
}

func (g *Generator) instanceName(f *File, v *Value) string {
	return fmt.Sprintf("%[1]s%[2]s", v.originalName, g.typeName)
}

const validateVarTemplate = `var _ %[1]s = %[2]s
`

const instanceTemplate = `%[1]s%[2]s = %[1]s("%[1]s") // %[1]s %[2]s
`

//const funcTemplate = `// %[4]s%[5]s
//%[6]s
//func (%[3]s) %[4]s%[5]s(v interface{}) (string, error) {
//		raw, err := %[1]s%[2]s.Marshal(v)
//	return string(raw), err
//}
//`

//func (Coders) JsonMarshal(v interface{}) (string, error) {
//	return jsonCoder.Marshal(v)
//}
//
// arg1: type name
//
// arg2: parent type name
//
// arg3: interface method name
//
// arg4: receiver
//
// arg5: method args
//
// arg6: out args
//
// arg7: in arg names
//
// arg8: comment
//
// arg9: type name with first upper word
const funcTemplate = `// %[9]s%[3]s
%[8]s
func (%[4]s) %[9]s%[3]s(%[5]s) (%[6]s) {
	return %[1]s%[2]s.%[3]s(%[7]s)
}
`
