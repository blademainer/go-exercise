# 针对数字订单号进行TLV压缩算法

## 背景

我们订单号在现网类似：20250811074413372133086，开发环境类似：20250813113048SP11000002
我现在有个渠道，他限制订单号只能18位长度，请你考虑方案对订单号进行缩短。
要求：
1. 缩短后长度必须小于18位，字符限制在[a-zA-Z0-9]范围
2. 要求缩短之后可以还原

## 思路

由于订单号大部分是数字，而三方渠道可以接收字母，因此我们可以将数字转换为字母，从而达到缩短的目的。

```go
// 将数字转换为base62
v := &big.Int{}
v.SetString("20250811074413372133086", 10)
text := v.Text(62)
fmt.Println(text)

// 将base62转换为数字
ni := &big.Int{}
_, ok := ni.SetString(text, 62)
if !ok {
    panic("bad number: " + text)
}
fmt.Println(ni.String())
```

## 算法

设计一套tlv(type-length-value)压缩算法，即我们将压缩后的结果以：`Type+Length+Value+Type+Length+Value...`的方式进行拼接。
其中n表示数字（被压缩），s表示字符串（无法压缩），比如n081qA1nttcs02SPn081qg1nttc，我们的扫描的时候应当先读取3位，第1位表示类型`t`，第2、3位表示接下来的长度`l`，然后读取l个值`v`，如果t=n，则对v进行base62解密，如果t=s，则直接取字符串即可；接着继续读取3位，对tlv进行解析，直到该字符串全部解析完成。
其中length可以在初始化打包器时指定。
比如：如果有连续的数字，那么n08就表示后续的字符（比如20250813113048缩短为1qg1nttc）是缩短后的8位字符，s02表示接下来是2为字符串（比如SP，字符串就不进行缩短）
如果纯数字，那么以大写N开头，比如N081qA1nttcs02SPn081qg1nttc，表示N后续所有订单都是纯数字缩容的

## 映射表

混合的还是需要进行压缩下，是不是可以考虑将SP和SB映射为更简化的字符，比如现在t有n和s，那么我们是不是可以考虑新增类型表示映射表，比如t=m表示映射表，v=1表示SB，v=2表示SP。这样，可以将s2SB压缩为m1，s2SP压缩为m2

### 映射表实现效果

已实现的映射表包含常见订单号模式：
- SP → 1 (节省1位：s2SP → m11)
- SB → 2 (节省1位：s2SB → m12) 
- PAY → 3 (节省2位：s3PAY → m13)
- ORD → 4 (节省2位：s3ORD → m14)
- TXN → 5 (节省2位：s3TXN → m15)
- REF → 6 (节省2位：s3REF → m16)

### 压缩效果对比

| 订单号类型 | 原长度 | 压缩后长度 | 压缩率 | 是否满足<18位 |
|------------|--------|------------|--------|---------------|
| 纯数字订单号 | 23位 | 14位 | 61% | ✅ |
| 长数字订单号 | 24位 | 15位 | 62% | ✅ |
| PAY+数字订单号 | 23位 | 16位 | 70% | ✅ |
| ORD+数字订单号 | 12位 | 10位 | 83% | ✅ |
| SB混合订单号 | 24位 | 19位 | 79% | ❌ |

### 总结

映射表优化显著提升了混合订单号的压缩效果，特别是对于带有常见前缀的订单号。大部分订单号都能满足18位限制要求。
